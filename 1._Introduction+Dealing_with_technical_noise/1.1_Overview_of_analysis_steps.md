# Overview of RNA-Seq analysis

## 0. Preliminaries

### Notation

A line beginning with a dollar sign (`$`) indicates the command line. It is meant to orient you that the command is to be performed in the terminal.
    
    $ 
    
This is not to be confused with something like `$HOME`, which means a variable named "HOME" that has the value (on my computer), shown by `echo` (which prints the output of commands). The dollar sign here means to access that variable. The line after the command line means the output of the command.

    $ echo $HOME 
    /Users/olga

### Anatomy of a Unix command

We'll be using unix commands here and it's worth pausing and talking about what these commands are really doing. Let's pretend we have a program called `libraryprep`. We can call the program using its name:

    $ libraryprep
    
Let's say it has the option flag (aka "flag" aka "argument") `--stranded`. You'd tell the program this flag by putting it after the command:

    $ libraryprep --stranded
    
A lot of times there's a shortened version of the flag. For `--stranded` let's say it's `-s`. Then you could use the shorter command,

    $ libraryprep -s

If a flag requires an input, you would put it immediately after the flag. For example, say we have a flag called `--input` and it requires the cell lysis file:

    $ libraryprep -s --input lysis
    
Now Let's say it has the options `-a`, `-s`, `-d`, `-f` We can put all of them sequentially:

    $ libraryprep -a -s -d -f
    
Or put them all in a row after a single dash. So the above command is equivalent to:

    $ libraryprep -asdf
    
But if you have a multi-character flag like `--input` then that has to be separate:

    $ libraryprep -asdf --input


### Getting help

For most command-line programs, you can get help on how to actually use the program one of four ways. This is called finding the "usage" message. I've written them in priority order so, try the first one first, then the second, etc.

1. `$ programname`
    2. Without any arguments, this will call the program. Sometimes this will give you usage information, sometimes it will result in an error.
2. `$ programname -h`
    3. The `-h` is (generally) a universal short version flag for "help me!!! I don't know what's going on!!" Though sometimes that doesn't work either ...
3. `$ programname --help`
    4. The expanded version of `-h`
4. `$ man programname`
    5. `man` is for "manual" and will bring up the manual pages for that command

### Subcommands

Some programs we'll use will have subcommands. This means that we're calling a specific subprogram of a single program. For example, let's pretend we have a program called `microscopy`, and it has the subcommands `brightfield` and `fluorescence`. You wouldn't be able to call just `microscopy` by itself, because you need to specify the exact subprogram (in this analogy, the type of light inputs) that you want to use:

    $ microscopy
    Error: Must specify either "brightfield" or "fluorescence"


There will be flags like `--zoom` that would make sense for both subcommands:

    $ microscopy brightfield --zoom 10x
    
But only for the `fluorescence` subcommand does the flag `--wavelength` make any sense, since `brightfield` would show all the light.
    
    $ microscopy fluorescence --wavelength 488 --zoom 10x
    
### "Standard in" and "standard out"

Some of these commands use the greater than (`>`), which means that the output of the program should be saved a file. I like to think of it as the big input (the left side of the `>`) being squeezed into the small corner of the arrow (right side of the `>`).

For example, let's go back to our `libraryprep` example. We tell the `libraryprep` program we want a stranded library with our `lysis` input, and to save it as the file called `cdna`.

    $ libraryprep --stranded --input lysis > cdna

## 1. Library quality control

### `.fastq` file format

#### PHRED64 quality scores

* Input: Raw `.fastq` files
* Program: FASTQC, SeQC
* Output: Report (`.html`) and plots (`.png`) of library quality

Example:

    $ fastqc \
        /home/obotvinnik/projects/treutlein2014/analysis/treutlein2014_v1/SRR1033944_1.polyATrim.adapterTrim.rep.bamUnmapped.out.mate1 \
        '-o' '/home/obotvinnik/projects/treutlein2014/analysis/treutlein2014_v1' \
        > /home/obotvinnik/projects/treutlein2014/analysis/treutlein2014_v1/SRR1033944_1.polyATrim.adapterTrim.rep.bamUnmapped.out.mate1.dummy_fastqc 

## 2. Adapter trimming

* Input: Raw `.fastq` files
* Program: `cutadapt`, `trimgalore`
* Output: Adapter trimmed `.fastq` files

Example:

    cutadapt \
        # format of the input files \
        -f fastq  \
        # Maximum number of times an adapter sequence can be removed \
        --times 2 \
        # Maximum error rate in adapter \
        -e 0.0  \
        # Minimum overlap length \
        -O 5  \
        # Minimum sequencing quality \
        --quality-cutoff 6 \
        # Minimum read length \
        -m 18 \
        # Adapters that could appear anywhere in the sequencing read (5' end or 3' end) \
        -b TCGTATGCCGTCTTCTGCTTG \
        -b ATCTCGTATGCCGTCTTCTGCTTG \
        -b CGACAGGTTCAGAGTTCTACAGTCCGACGATC \
        -b GATCGGAAGAGCACACGTCTGAACTCCAGTCAC \
        -b AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \
        -b TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT \
        # Read 1 output \
        -o $HOME/projects/shalek2013/processed_data/S10_R1.polyATrim.adapterTrim.fastq \
        # Read 2 output \
        -p $HOME/projects/shalek2013/processed_data/S10_R2.polyATrim.adapterTrim.fastq \
        # Read 1 input \
        $HOME/projects/shalek2013/raw_data/S10_R1.fastq.gz \
        # Read 2 input \
        $HOME/projects/shalek2013/raw_data/S10_R2.fastq.gz \
        # Statistics about how many adapters were removed
        > $HOME/projects/shalek2013/processed_data/S10_R2.polyATrim.adapterTrim.metrics

## 3. Map to repetitive elements

### `.sam` file format

"Sequence alignment map"


* Input: Trimmed `.fastq` files and repetitive element "genome"
* Program: `STAR`
* Output: Alignment `.sam` and unaligned `.fastq`

Example:

    STAR \
        --runThreadN 16 \
        --genomeDir \
        /projects/ps-yeolab/genomes/RepBase18.05.fasta/STAR/ \
        --readFilesIn \
        $HOME/projects/shalek2013/processed_data/S10_R1.polyATrim.adapterTrim.fastq \
        $HOME/projects/shalek2013/processed_data/S10_R1.polyATrim.adapterTrim.fastq \
        --outFileNamePrefix $HOME/projects/shalek2013/processed_data/S10.repetitive \
        --outReadsUnmapped Fastx

## 4. Map to transcriptome

* Input: `.fastq` of trimmed reads which didn't align to transcriptome
* Program: `STAR`
* Output: Alignment `.sam`

Example:
    
    STAR \
        --runThreadN 16 \
        --genomeDir /projects/ps-yeolab/biom262-2016/genomes/mm10/gencode/m8/star/ \
        --readFilesIn $HOME/projects/shalek2013/raw_data/S10_R1.fastq.gz $HOME/projects/shalek2013/raw_data/S10_R2.fastq.gz \
        --outFileNamePrefix $HOME/projects/shalek2013/processed_data/S10. \
        --readFilesCommand zcat

## 5. Create sorted, indexed `.bam` file


### `.bam` file format

The `.bam` file format is a compressed (aka "binary" - meaning not human readable) version of the `.sam` format.

All programs downstream of mapping require a sorted, indexed `.bam` file. You can also do these steps with your repetitive element-aligned `.sam` file if 

Think of creating a sorted, indexed bam file like making a dictionary. 

A raw aligned `.sam` file like a jumble of words in random order:

    single
    cell
    bioinformatics
    experiment
    beyonce
    sequencing
    library
    prep

Sorting puts the words into alphabet order:

    beyonce
    bioinformatics
    cell
    experiment
    library
    prep
    sequencing
    single

And indexing is like adding the alphabet tabs in a dictionary:

    B:
        beyonce
        bioinformatics
    C:
        cell
    E:
        experiment
    L: 
        library
    P:
        prep
    S:
        sequencing
        single

Instead of letters, indexing adds "chromosome tabs" so each program will know where, say chromosome 7 (`chr7`) starts and can jump to it right away.



### 5.1 Sort `.sam`

For deeply sequenced samples (>50 million reads), this will take quite some time

* Input: `.sam` of transcriptome-aligned reads
* Program: `samtools sort`
* Output: Sorted `.bam`

Example (`samtools v1.3.1`): 

    samtools sort sample01.sam > sample01.sorted.bam
    
### 5.2 Index `.sam`

Indexing only works with sorted bam files

* Input: `.bam` of *sorted*, transcriptome-aligned reads
* Program: `samtools sort`
* Output: Sorted `.bam`

Example (`samtools v1.3.1`): 

    samtools sort sample01.sorted.bam

This creates the file `sample01.sorted.bam.bai`
    

## 6. Quantify gene expression

### Units

TPM, FPKM, what? Check out this blog post on [What the FPKM?](https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/) to learn about RNA-seq units in depth.

* Input: `.bam` of *sorted*, transcriptome-aligned reads
* Program: `featureCounts`, Salmon, HTSeq, ...
* Output: ?? some kind of table (comma- or tab-delimited file)

## 7. Create gene expression matrix

* Input: Individual cells' gene expression counts
* Program: R, Python, `awk`, `cut`, `paste`
* Output: A matrix of size (`n_samples` $\times$ `n_features`)

## 8. Cell-level QC

* Input: Gene expression matrix
* Program: R, Python, MATLAB
* Possible criteria: 
    * Low number of reads mapped (indicates lowly sequenced)
    * Low percentage of reads mapped (indicates poor library)
    * High mitochondrial:genome ratio (indicates dying cell)
    * High spike-in:genome ratio (indicates low cellular mRNA content)
    * Low numbers of expressed genes (indicates low detection)
* Output: Gene expression matrix with "bad" cells removed

## 9. Gene-level QC

* Input: Gene expression matrix with "bad" cells removed
* Program: R, Python, MATLAB
* Possible criteria:
    * Low expression (e.g. $< 1$ TPM in $> 5$ cells)
* Output: Gene expression matrix with "bad" genes removed


## 10. Exploratory analysis

* Input: Gene expression matrix with "bad" genes removed
* Program: R, Python, MATLAB
* Possible algorithms:
    * Dimensionality reduction
        * PCA
        * ICA
        * MDS
        * t-SNE
* Output: plots


## 11. Subpopulation identification

* Input: Gene expression matrix with "bad" genes removed
* Program: R, Python, MATLAB
* Possible algorithms:
    * Clustering
        * Hierarchical clustering
        * $K$-means
    * Pseudo-time
        * Monocle
        * Waterfall
        * Wanderlust
        * Wishbone
* Output: plots, cluster identification


## 12. Subpopulation characterization

* Input: Gene expression matrix with "bad" genes removed, cluster or psuedotime ordering
* Program: R, Python, MATLAB
* Possible algorithms:
    * Differential expression
        * DESeq
        * scDE ("single-cell differential expression")
    * Classifiers
        * Support Vector Machines (SVM)
        * DecisionTree classifiers
    * Clustering
        * Hierarchical clustering on ordered gene expression
* Output: Lists of genes

## 13. Interpretation

* Input: Lists of genes
* Program: Biologist, Gene Ontology (e.g. DAVID) or other gene set enrichment analysis, PubMed
* Output: Biological description of populations
